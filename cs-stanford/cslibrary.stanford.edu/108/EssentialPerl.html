<!doctype html public "-//w3c//dtd html 4.0 transitional//en"><html><head>   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">   <meta name="GENERATOR" content="Mozilla/4.79 (Macintosh; U; PPC) [Netscape]">   <meta name="Author" content="Nick Parlante">   <meta name="Description" content="A free introduction to the Perl language.">   <meta name="Keywords" content="Perl, introduction">   <meta name="Content-Type" content="text/html; charset=iso-8859-1">   <title>Essential Perl</title></head><body bgcolor="#FFFFFF"><center><h1><font size=+4>Essential Perl</font></h1></center>This document is a quick introduction to the Perl language. Perl has manyfeatures, but you can get pretty far with just the basics, and that's whatthis document is about. The coverage is pretty quick, intended for peoplewith some programming experience. This document is available for free inthe spirit of engineering goodwill -- that success is not taken, it isearned.<center><p><font size=-1>Stanford CS Education #108</font><br><font size=-1>http://cslibrary.stanford.edu/108/</font><br><font size=-1>by Nick Parlante copyright (c) 2000-2002</font><br><font size=-1><a href="#revision">Revised</a> 5/2002</font></center><p>This is document #108 in the Stanford CS Education Library -- see <a href="http://cslibrary.stanford.edu/108/">http://cslibary.stanford.edu/108/</a>for this and other free educational CS materials. This document is freeto be used, reproduced, or sold so long as this paragraph and the copyrightare clearly reproduced.<h2>Contents</h2><ol><li><a href="#aboutperl">What is Perl?</a></li><li><a href="#syntaxvars">Variables</a></li><li><a href="#strings">Strings</a></li><li><a href="#arrays">Arrays</a></li><li><a href="#associative">Associative Arrays</a></li><li><a href="#control">If, while, etc.</a></li><li><a href="#iofiles">File Input</a></li><li><a href="#printoutput">Print output</a></li><li><a href="#re">Strings and Regular Expressions</a></li><li><a href="#subroutines">Subroutines</a></li><li><a href="#external">Running External Programs</a></li><li><a href="#references">References</a></li><li><a href="#terse">Terse Perl</a></li></ol><h1><a NAME="aboutperl"></a>1. What Is Perl?</h1>Perl is a free, open source programming language created by Larry Wall.Perl aims for adjectives like "practical" and "quick" and not so much wordslike "structured" or "elegant". A culture has built up around Perl wherepeople create and give away modules, documentation, sample code, and athousand other useful things -- visit the Comprehensive Perl Archive Network(CPAN), <a href="http://www.cpan.org/">http://www.cpan.org/</a>, or <a href="http://www.perl.com/">http://www.perl.com/</a>to see the amazing range of Perl material available.<h2>Perl Niche</h2>Perl is probably best known for text processing -- dealing with files,strings, and regular expressions. However, Perl's quick, informal stylemakes it attractive for all sorts of little programs. If I need a 23 lineprogram to get some task done, I can write it in Perl and be done in 3minutes. Perl code is very portable -- I frequently move Perl programsback and forth from the Mac to various Unixes and it just works. With Perl,you are not locked in to any particular vendor or operating system. Perlcode is also robust; Perl programs can have bugs, but they will not crashrandomly like C or C++ programs. On the other hand, in my opinion, Perl'seasy-going style makes it less appealing for large projects where I wouldrather use Java.<h2>Warning: My Boring Perl Style</h2>Perl is famous for allowing you to write solutions to complex problemswith very short, terse phrases of code. There's something satisfying aboutreducing a whole computation down to a single line of dense code. However,I never do that. I write Perl code in a boring, straightforward way whichtends to spell out what it's actually doing step by step. The terse styleis mentioned briefly in the <a href="#terse">Terse Perl</a> section. Also,in versions 5 and 6, Perl has accumulated more sophisticated features whichare not covered here. We just do simple old Perl code.<h2>Running Perl</h2>A Perl program is just a text file. You edit the text of your Perl program,and the Perl interpreter reads that text file directly to "run" it. Thisstructure makes your edit-run-debug cycle nice and fast. On Unix, the Perlinterpreter is called "perl"&nbsp; and you run a Perl program by runningthe Perl interpreter and telling it which file contains your Perl program...<p><tt>> perl myprog.pl</tt><br>&nbsp;<p>The interpreter makes one pass of the file to analyze it and if thereare no syntax or other obvious errors, the interpreter runs the Perl code.There is no "main" function -- the interpreter just executes the statementsin the file starting at the top.<p>Following the Unix convention, the very first line in a Perl file usuallylooks like this...<p><tt>#!/usr/bin/perl -w</tt><br>&nbsp;<p>This special line is a hint to Unix to use the Perl interpreter to executethe code in this file. The "-w" switch turns on warnings which is generallya good idea. In unix, use "chmod" to set the execute bit on a Perl fileso it can be run right from the prompt...<p><tt>> chmod u+x foo.pl&nbsp; ## set the "execute" bit for the file once</tt><br><tt>></tt><br><tt>> foo.pl&nbsp;&nbsp;&nbsp;&nbsp; ## automatically uses the perlinterpreter to "run" this file</tt><p>The second line in a Perl file is usually a "require" declaration thatspecifies what version of Perl the program expects...<p><tt>#!/usr/bin/perl -w</tt><br><tt>require 5.004;</tt><br>&nbsp;<p>Perl is available for every operating system imaginable, including ofcourse Windows and MacOS, and it's part of the default install in Mac OSX.See the "ports" section of <a href="http://www.cpan.org/">http://www.cpan.org/</a>to get Perl for a particular system.<h1><a NAME="syntaxvars"></a>2. Syntax And Variables</h1>The simplest Perl variables are "scalar" variables which hold a singlestring or number. Scalar variable names begin with a dollar sign ($) suchas <tt>$sum</tt> or <tt>$greeting</tt>. Scalar and other variables do notneed to be pre-declared -- using a variable automatically declares it asa global variable. Variable names and other identifiers are composed ofletters, digits, and underscores (_) and are case sensitive. Comments beginwith a "#" and extend to the end of the line.<p><tt>$x = 2; ## scalar var $x set to the number 2</tt><br><tt>$greeting = "hello"; ## scalar var $greeting set to the string"hello"</tt><p>A variable that has not been given a value has the special value "undef"which can be detected using the "defined" operator. Undef looks like 0when used as a number, or the empty string "" when used as a string, althougha well written program probably should not depend on undef in that way.When Perl is run with "warnings" enabled (the -w flag), using an undefvariable prints a warning.<p><tt>if (!defined($binky)) {</tt><br><tt>&nbsp; print "the variable 'binky' has not been given a value!\n";</tt><br><tt>}</tt><br>&nbsp;<h2>What's With This '$' Stuff?</h2>Larry Wall, Perl's creator, has a background in linguistics which explainsa few things about Perl. I saw a Larry Wall talk where he gave a sort ofexplanation for the '$' syntax in Perl: In human languages, it's intuitivefor each part of speech to have its own sound pattern. So for example,a baby might learn that English nouns end in "-y" -- "mommy," "daddy,""doggy".&nbsp; (It's natural for a baby to over generalize the "rule" toget made up words like "bikey" and "blanky".) In some small way, Perl triesto capture the different-signature-for-different-role pattern in its syntax-- all scalar expressions look alike since they all start with '$'.<h1><a NAME="strings"></a>3. Strings</h1>Strings constants are enclosed within double quotes (") or in single quotes('). Strings in double quotes are treated specially -- special directiveslike <tt>\n</tt> (newline) and <tt>\x20</tt> (hex 20) are expanded. Moreimportantly, a variable, such as $x, inside a double quoted string is evaluatedat run-time and the result is pasted into the string. This evaluation ofvariables into strings is called "interpolation" and it's a great Perlfeature. Single quoted (') strings suppress all the special evaluation--&nbsp; they do not evaluate \n or $x, and they may contain newlines.<p><tt>$fname = "binky.txt";</tt><br><tt>$a = "Could not open the file $fname.";&nbsp; ## $fname evaluatedand pasted in -- neato!</tt><br><tt>$b = 'Could not open the file $fname.';&nbsp; ## single quotes(') do no special evaluation</tt><p><tt>## $a is now "Could not open the file binky.txt."</tt><br><tt>## $b is now "Could not open the file $fname."</tt><br>&nbsp;<p>The characters '$' and '@' are used to trigger interpolation into strings,so those characters need to be escaped with a backslash (\) if you wantthem in a string. For example: <tt>"nick\@stanford.edu found \$1"</tt>.<p>The dot operator (.) concatenates two strings. If Perl has a numberor other type when it wants a string, it just silently converts the valueto a string and continues. It works the other way too -- a string suchas "42" will evaluate to the integer 42 in an integer context.<p><tt>$num = 42;</tt><br><tt>$string = "The " . $num . " ultimate" . " answer";</tt><p><tt>## $string is now "The 42 ultimate answer"</tt><br>&nbsp;<p>The operators <tt>eq</tt> (equal) and <tt>ne</tt> (not equal) comparetwo strings. Do not use <tt>==</tt> to compare strings; use <tt>==</tt>to compare numbers.<p><tt>$string = "hello";</tt><br><tt>($string eq ("hell" . "o"))&nbsp; ==> TRUE</tt><br><tt>($string eq "HELLO")&nbsp; ==> FALSE</tt><p><tt>$num = 42;</tt><br><tt>($num-2 == 40)&nbsp; ==> TRUE</tt><p>The lc("Hello") operator returns the all lower-case version "hello",and uc("Hello") returns the all upper-case version "HELLO".<h2>Fast And Loose Perl</h2>When Perl sees an expression that doesn't make sense, such as a variablethat has not been given a value, it tends to just silently pass over theproblem and use some default value such as undef. This is better than Cor C++ which tend to crash when you do something wrong. Still, you needto be careful with Perl code since it's easy for the language to do somethingyou did not have in mind. Just because Perl code compiles, don't assumeit's doing what you intended. Anything compiles in Perl.<h1><a NAME="arrays"></a>4. Arrays -- @</h1>Array constants are specified using parenthesis (&nbsp; ) and the elementsare separated with commas. Perl arrays are like lists or collections inother languages since they can grow and shrink, but in Perl they are justcalled "arrays". Array variable names begin with the at-sign (@). UnlikeC, the assignment operator (=) works for arrays -- an independent copyof the array and its elements is made. Arrays may not contain other arraysas elements. Perl has sort of a "1-deep" mentality. Actually, it's possibleto get around the 1-deep constraint using "<a href="#references">references</a>",but it's no fun. Arrays work best if they just contain scalars (stringsand numbers). The elements in an array do not all need to be the same type.<p><tt>@array = (1, 2, "hello");&nbsp; ## a 3 element array</tt><br><tt>@empty = ();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## the array with 0 elements</tt><p><tt>$x = 1;</tt><br><tt>$y = 2;</tt><br><tt>@nums = ($x + $y, $x - $y);</tt><p><tt>## @nums is now (3, -1)</tt><p>Just as in C, square brackets [ ] are used to refer to elements, so$a[6] is the element at index 6 in the array @a. As in C, array indexesstart at 0. Notice that the syntax to access an element begins with '$'not '@' -- use '@' only when referring to the whole array (remember: allscalar expressions begin with $).<p><tt>@array = (1, 2, "hello", "there");</tt><br><tt>$array[0] = $array[0] + $array[1];&nbsp;&nbsp;&nbsp; ## $array[0]is now 3</tt><br>&nbsp;<p>Perl arrays are not bounds checked. If code attempts to read an elementoutside the array size, undef is returned. If code writes outside the arraysize, the array grows automatically to be big enough. Well written codeprobably should not rely on either of those features.<p><tt>@array = (1, 2, "hello", "there");</tt><br><tt>$sum = $array[0] + $array[27];&nbsp;&nbsp;&nbsp; ## $sum is now1, since $array[27] returned undef</tt><p><tt>$array[99] = "the end";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## array grows to be size 100</tt><p>When used in a scalar context, an array evaluates to its length. The"scalar" operator will force the evaluation of something in a scalar context,so you can use scalar() to get the length of an array. As an alternativeto using scalar, the expression <tt>$#array</tt> is the index of the lastelement of the array which is always one less than the length.<p><tt>@array = (1, 2, "hello", "there");</tt><br><tt>$len = @array;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## $len is now 4 (the length of @array)</tt><p><tt>$len = scalar(@array)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## same as above, since $len represented a scalar</tt><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## context anyway, but this is more explicit</tt><p><tt>@letters = ("a", "b", "c");</tt><br><tt>$i = $#letters;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## $i is now 2</tt><br>&nbsp;<p>That <tt>scalar(@array)</tt> is the way to refer to the length of anarray is not a great moment in the history of readable code. At least Ihaven't showed you the even more vulgar forms such as <tt>(0 + @a)</tt>.<p>&nbsp;The sort operator <tt>(sort @a)</tt> returns a copy of the arraysorted in ascending alphabetic order. Note that sort does not change theoriginal array. Here are some common ways to sort...<p><tt>(sort @array)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## sort alphabetically, with uppercase first</tt><br><tt>(sort {$a &lt;=> $b} @array)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## sort numerically</tt><br><tt>(sort {$b cmp $a} @array)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## sort reverse alphabetically</tt><br><tt>(sort {lc($a) cmp lc($b)} @array)&nbsp;&nbsp;&nbsp; ## sort alphabetically,ignoring case (somewhat inefficient)</tt><p>The sort expression above pass a comparator function <tt>{...} </tt>tothe sort operator, where the special variables<tt> $a</tt> and<tt> $b</tt>are the two elements to compare -- <tt>cmp </tt>is the built-in stringcompare, and <tt>&lt;=></tt> is the built-in numeric compare.<p>There's a variant of array assignment that is used sometimes to assignseveral variables at once. If an array on the left hand side of an assignmentoperation contains the names of variables, the variables are assigned thecorresponding values from the right hand side.<p><tt>($x, $y, $z) = (1, 2, "hello", 4);</tt><p><tt>## assigns $x=1, $y=2, $z="hello", and the 4 is discarded</tt><p>This type of assignment only works with scalars. If one of the valuesis an array, the wrong thing happens (see "flattening" below).<br>&nbsp;<h2>Array Add/Remove/Splice Functions</h2>These handy operators will add or remove an element from an array. Theseoperators change the array they operate on...<ul><li>Operating at the "front" ($array[0]) end of the array...</li><ul><li><tt>shift(array)&nbsp;</tt> -- returns the frontmost element and removesit from the array. Can be used in a loop to gradually remove and examineall the elements in an array left to right. The foreach operator, below,is another way to examine all the elements.</li><li><tt>unshift(array, elem)&nbsp; </tt>-- inserts an element at the frontof the array. Opposite of shift.</li></ul><li>Operating at the "back" ($array[$len-1]) end of the array...</li><ul><li><tt>pop(array)&nbsp;</tt> -- returns the endmost element (right hand side)and removes it from the array.</li><li><tt>push(array, elem)</tt>&nbsp; -- adds a single element to the end ofthe array. Opposite of pop.</li></ul><li><tt>splice(array, index, length, array2)</tt> -- removes the section ofthe array defined by index and length, and replaces that section with theelements from array2. If array2 is omitted, splice() simply deletes. Forexample, to delete the element at index $i from an array, use splice(@array,$i, 1).</li></ul><h1><a NAME="associative"></a>5. Hash Arrays -- %</h1>Hash arrays, also known as "associative" arrays, are a built-in key/valuedata structure. Hash arrays are optimized to find the value for a key veryquickly. Hash array variables begin with a percent sign (%) and use curlybraces { } to access the value for a particular key. If there is no suchkey in the array, the value returned is undef. The keys are case sensitive,so you may want to consistently uppercase or lowercase strings before usingthem as a key (use lc and uc).<p><tt>$dict{"bart"}&nbsp; = "I didn't do it";</tt><br><tt>$dict{"homer"} = "D'Oh";</tt><br><tt>$dict{"lisa"}&nbsp; = "";</tt><p><tt>## %dict now contains the key/value pairs (("bart" => "I didn'tdo it"),</tt><br><tt>## ("homer" => "D'oh"), ("lisa" => ""))</tt><p><tt>$string = $dict{"bart"};&nbsp;&nbsp;&nbsp;&nbsp; ## Lookup the key"bart" to get</tt><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## the value "I didn't do it"</tt><p><tt>$string = $dict{"marge"};&nbsp;&nbsp;&nbsp; ## Returns undef --there is no entry for "marge"</tt><p><tt>$dict{"homer"} = "Mmmm, scalars";&nbsp;&nbsp;&nbsp; ## change thevalue for the key</tt><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## "homer" to "Mmmm, scalars"</tt><br>&nbsp;<p>A hash array may be converted back and forth to an array where eachkey is immediately followed by its value. Each key is adjacent to its value,but the order of the key/value pairs depends on the hashing of the keysand so appears random. The "keys" operator returns an array of the keysfrom an associative array. The "values" operator returns an array of allthe values, in an order consistent with the keys operator.<p><tt>@array = %dict;</tt><p><tt>## @array will look something like</tt><br><tt>##&nbsp; ("homer", "D'oh", "lisa", "", "bart", "I didn't do it");</tt><br><tt>##</tt><br><tt>## (keys %dict) looks like ("homer", "lisa, "bart")</tt><br><tt>## or use (sort (keys %dict))</tt><br>&nbsp;<p>You can use <tt>=></tt> instead of comma and so write a hash array valuethis cute way...<p><tt>%dict = (</tt><br><tt>&nbsp; "bart" => "I didn't do it",</tt><br><tt>&nbsp; "homer" => "D'Oh",</tt><br><tt>&nbsp; "lisa" => "",</tt><br><tt>);</tt><br>&nbsp;<p>In Java or C you might create an object or struct to gather a few itemstogether. In Perl you might just throw those things together in a hasharray.<br>&nbsp;<h2>@ARGV and %ENV</h2>The built-in array @ARGV contains the command line arguments for a Perlprogram. The following run of the Perl program critic.pl will have theARGV array ("-poetry", "poem.txt").<p><tt>unix% perl critic.pl -poetry poem.txt</tt><br>&nbsp;<p>%ENV contains the environment variables of the context that launchedthe Perl program. @ARGV and %ENV make the most sense in a Unix environment.<h1><a NAME="control"></a>6. If/While Syntax</h1>Perl's control syntax looks like C's control syntax . Blocks of statementsare surrounded by curly braces { }. Statements are terminated with semicolons(;). The parenthesis and curly braces are <b>required </b>in if/while/forforms. There is not a distinct "boolean" type, and there are no "true"or "false" keywords in the language. Instead, the empty string, the emptyarray, the number 0 and undef all evaluate to false, and everything elseis true. The logical operators &amp;&amp;, ||, ! work as in C. There arealso keyword equivalents (and, or, not) which are almost the same, buthave lower precedence.<h2>IF</h2><tt>if (<i>expr</i>) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## basic if -- ( ) and { } required</tt><br><tt>&nbsp; <i>stmt</i>;</tt><br><tt>&nbsp; <i>stmt</i>;</tt><br><tt>}</tt><p><tt>if (<i>expr</i>) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## if + elsif + else</tt><br><tt>&nbsp; <i>stmt</i>;</tt><br><tt>&nbsp; <i>stmt</i>;</tt><br><tt>}</tt><br><tt>elsif (<i>expr</i>) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ## note thestrange spelling of "elsif"</tt><br><tt>&nbsp; <i>stmt</i>;</tt><br><tt>&nbsp; <i>stmt</i>;</tt><br><tt>}</tt><br><tt>else {</tt><br><tt>&nbsp; <i>stmt</i>;</tt><br><tt>&nbsp; <i>stmt</i>;</tt><br><tt>}</tt><p><tt>unless (<i>expr</i>) {&nbsp;&nbsp;&nbsp;&nbsp; ## if variant whichnegates the boolean test</tt><br><tt>&nbsp; <i>stmt</i>;</tt><br><tt>&nbsp; <i>stmt</i>;</tt><br><tt>}</tt><br>&nbsp;<h2>If Variants</h2>As an alternative to the classic <tt>if() { } </tt>structure, you may use<tt>if</tt>,<tt>while</tt>,and <tt>unless</tt> as modifiers that come<b>after</b> the single statementthey control...<p><tt>$x = 3 if $x > 3;&nbsp; ## equivalent to: if ($x > 3) { $x = 3;}</tt><p><tt>$x = 3 unless $x &lt;= 3;</tt><br>&nbsp;<p>For these constructs, the parentheses are not required around the booleanexpression. This may be another case where Perl is using a structure fromhuman languages. I never use this syntax because I just cannot get usedto seeing the condition after the statement it modifies. If you were defusinga bomb, would you like instructions like this: "Locate the red wire comingout of the control block and cut it. Unless it's a weekday -- in that casecut the black wire."<h2>Loops</h2>These work just as in C...<p><tt>while (<i>expr</i>) {</tt><br><tt>&nbsp;<i>stmt</i>;</tt><br><tt>&nbsp;<i>stmt</i>;</tt><br><tt>}</tt><p><tt>for (<i>init_expr</i>; <i>test_expr</i>; <i>increment_expr</i>){</tt><br><tt>&nbsp;<i>stmt</i>;</tt><br><tt>&nbsp;<i>stmt</i>;</tt><br><tt>}</tt><p><tt>## typical for loop to count 0..99</tt><br><tt>for ($i=0; $i&lt;100; $i++) {</tt><br><tt>&nbsp;<i>stmt</i>;</tt><br><tt>&nbsp;<i>stmt</i>;</tt><br><tt>}</tt><br>&nbsp;<p>The "<tt>next</tt>" operator forces the loop to the next iteration.The "<tt>last</tt>" operator breaks out of the loop like break in C. Thisis one case where Perl (last) does not use the same keyword name as C (break).<h2>Array Iteration — foreach</h2>The "foreach" construct is a handy way to iterate a variable over all theelements in an array. Because of foreach, you rarely need to write a traditionalfor or while loop to index into an array. Foreach is also likely to beimplemented efficiently. (It's a shame Java does not include a compactiteration syntax in the language. It would make Java a better languageat the cost of some design elegance.)<p><tt>foreach $var (@array) {</tt><br><tt>&nbsp; <i>stmt</i>;&nbsp;&nbsp;&nbsp; ## use $var in here</tt><br><tt>&nbsp; <i>stmt</i>;</tt><br><tt>}</tt><br>&nbsp;<p>Any array expression may be used in the foreach. The array expressionis evaluated once before the loop starts. The iterating variable, suchas $var, is actually a pointer to each element in the array, so assigningto $var will actually change the elements in the array.<h1><a NAME="iofiles"></a>7. File Input</h1>Variables which represent files are called "file handles", and they arehandled differently from other variables. They do not begin with any specialcharacter -- they are just plain words. By convention, file handle variablesare written in all upper case, like FILE_OUT or SOCK. The file handlesare all in a global namespace, so you cannot allocate them locally likeother variables. File handles can be passed from one routine to anotherlike strings (detailed below).<p>The standard file handles STDIN, STDOUT, and STDERR are automaticallyopened before the program runs. Surrounding a file handle with <tt>&lt;></tt>is an expression that returns one line from the file including the "\n"character, so &lt;STDIN> returns one line from standard input. The <tt>&lt;></tt>operator returns undef when there is no more input. The "chop" operatorremoves the last character from a string, so it can be used just afteran input operation to remove the trailing "\n".&nbsp; The "chomp" operatoris similar, but only removes the character if it is the end-of-line character.<p><tt>$line = &lt;STDIN>;&nbsp;&nbsp; ## read one line from the STDINfile handle</tt><br><tt>chomp($line);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ## remove the trailing"\n" if present</tt><p><tt>$line2 = &lt;FILE2>;&nbsp; ## read one line from the FILE2 filehandle</tt><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## which must be have been opened previously</tt><br>&nbsp;<p>Since the input operator returns undef at the end of the file, the standardpattern to read all the lines in a file is...<p><tt>## read every line of a file</tt><br><tt>while ($line = &lt;STDIN>) {</tt><br><tt>&nbsp; ## do something with $line</tt><br><tt>}</tt><br>&nbsp;<h2>Open and Close</h2>The "open" and "close" operators operate as in C to connect a file handleto a filename in the file system.<p><tt>open(F1, "filename");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ## open "filename"for reading as file handle F1</tt><br><tt>open(F2, ">filename");&nbsp;&nbsp;&nbsp;&nbsp; ## open "filename"for writing as file handle F2</tt><br><tt>open(F3, ">>appendtome")&nbsp;&nbsp; ## open "appendtome" for appending</tt><p><tt>close(F1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## close a file handle</tt><p>Open can also be used to establish a reading or writing connection toa separate process launched by the OS. This works best on Unix.<p><tt>open(F4, "ls -l |");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ## opena pipe to read from an ls process</tt><br><tt>open(F5, "| mail $addr");&nbsp; ## open a pipe to write to a mailprocess</tt><p>Passing commands to the shell to launch an OS process in this way canbe very convenient, but it's also a famous source of security problemsin CGI programs. When writing a CGI, do not pass a string from the clientside as a filename in a call to open().<p>Open returns undef on failure, so the following phrase is often to exitif a file can't be opened. The die operator prints an error message andterminates the program.<p><tt>open(FILE, $fname) || die "Could not open $fname\n";</tt><p>In this example, the logical-or operator <tt>||</tt>&nbsp; essentiallybuilds an if statement, since it only evaluates the second expression ifthe first if false. This construct is a little strange, but it is a commoncode pattern for Perl error handling.<h2>Input Variants</h2>In a scalar context the input operator reads one line at a time. In anarray context, the input operator reads the entire file into memory asan array of its lines...<p><tt>@a = &lt;FILE>;&nbsp; ## read the whole file in as an array of lines</tt><p>This syntax can be dangerous. The following statement looks like itreads just a single line, but actually the left hand side is an array context,so it reads the whole file and then discards all but the first line....<p><tt>my($line) = &lt;FILE>;</tt><br>&nbsp;<p>The behavior of &lt;FILE> also depends on the special global variable<tt>$/</tt>which is the current the end-of-line marker (usually "\n"). Setting <tt>$/</tt>to undef causes &lt;FILE> to read the whole file into a single string.<p><tt>$/ = undef;</tt><br><tt>$all = &lt;FILE>;&nbsp;&nbsp;&nbsp; ## read the whole file intoone string</tt><br>&nbsp;<p>You can remember that <tt>$/</tt> is the end-of-line marker because"<tt>/</tt>"&nbsp; is used to designate separate lines of poetry. I thoughtthis mnemonic was silly when I first saw it, but sure enough, I now rememberthat <tt>$/</tt> is the end-of-line marker.<br>&nbsp;<h1><a NAME="printoutput"></a>8. Print Output</h1>Print takes a series of things to print separated by commas. By default,print writes to the STDOUT file handle.<p><tt>print "Woo Hoo\n";&nbsp;&nbsp; ## print a string to STDOUT</tt><p><tt>$num = 42;</tt><br><tt>$str = " Hoo";</tt><br><tt>print "Woo", $a, " bbb $num", "\n";&nbsp; ## print several things</tt><br>&nbsp;<p>An optional first argument to print can specify the destination filehandle. There is no comma after the file handle, but I always forget toomit it.<p><tt>print FILE "Here", " there", " everywhere!", "\n"; ## no comma afterFILE</tt><br>&nbsp;<h2>File Processing Example</h2>As an example, here's some code that opens each of the files listed inthe @ARGV array, and reads in and prints out their contents to standardoutput...<p><tt>#!/usr/bin/perl -w</tt><br><tt>require 5.004;</tt><br><tt>## Open each command line file and print its contents to standardout</tt><p><tt>foreach $fname (@ARGV) {</tt><p><tt>&nbsp; open(FILE, $fname) || die("Could not open $fname\n");</tt><p><tt>&nbsp; while($line = &lt;FILE>) {</tt><br><tt>&nbsp;&nbsp;&nbsp; print $line;</tt><br><tt>&nbsp; }</tt><p><tt>&nbsp; close(FILE);</tt><br><tt>}</tt><br>&nbsp;<p>The above uses "die" to abort the program if one of the files cannotbe opened. We could use a more flexible strategy where we print an errormessage for that file but continue to try to process the other files. Alternatelywe could use the function call <tt>exit(-1)</tt> to exit the program withan error code. Also, the following shift pattern is a common alternativeway to iterate through an array...<p><tt>while($fname = shift(@ARGV)) {...</tt><br>&nbsp;<br>&nbsp;<h1><a NAME="re"></a>10. String Processing with Regular Expressions</h1>Perl's most famous strength is in string manipulation with regular expressions.Perl has a million string processing features -- we'll just cover the mainones here. The simple syntax to search for a pattern in a string is...<p><tt>($string =~ /<b>pattern</b>/)&nbsp; ## true if the <b>pattern</b>is found somewhere in the <b>string</b></tt><p><tt>("binky" =~ /ink/)&nbsp; ==> TRUE</tt><br><tt>("binky" =~ /onk/)&nbsp; ==> FALSE</tt><br>&nbsp;<p>In the simplest case, the exact characters in the regular expressionpattern must occur in the string somewhere. All of the characters in thepattern must be matched, but the pattern does not need to be right at thestart or end of the string, and the pattern does not need to use all thecharacters in the string.<h2>Character Codes</h2>The power of regular expressions is that they can specify patterns, notjust fixed characters. First, there are special matching characters...<ul><li><b>a</b>, <b>X</b>, <b>9</b> -- ordinary characters just match that characterexactly</li><li><b>.</b> (a period) -- matches any single character except "\n"</li><li><b>\w</b> -- (lowercase w) matches a "word" character: a letter or digit[a-zA-Z0-9]</li><li><b>\W</b> -- (uppercase W) any non word character</li><li><b>\s</b> -- (lowercase s) matches a single whitespace character -- space,newline, return, tab, form [ \n\r\t\f]</li><li><b>\S</b> -- (uppercase S) any non whitespace character</li><li><b>\t</b>, <b>\n</b>,<b> \r</b>&nbsp; -- tab, newline, return</li><li><b>\d</b> -- decimal digit [0-9]</li><li><b>\</b>&nbsp;&nbsp; -- inhibit the "specialness" of a character. So, forexample, use<b> \.</b> to match a period or <b>\\</b> to match a slash.If you are unsure if a character has special meaning, such as '@', youcan always put a slash in front of it \@ to make sure it is treated justas a character.</li></ul><tt>"piiig" =~ <b>/p...g/</b>&nbsp;&nbsp;&nbsp;&nbsp; ==> TRUE&nbsp;&nbsp;. = any char (except \n)</tt><p><tt>"piiig" =~ <b>/.../</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ==>TRUE&nbsp;&nbsp; need not use up the whole string</tt><p><tt>"piiig" =~ <b>/p....g/</b>&nbsp;&nbsp;&nbsp; ==> FALSE&nbsp; mustuse up the whole pattern (the g is not matched)</tt><p><tt>"piiig" =~ <b>/p\w\w\wg/</b>&nbsp; ==> TRUE&nbsp;&nbsp; \w = anyletter or digit</tt><p><tt>"p123g" =~ <b>/p\d\d\dg/</b>&nbsp; ==> TRUE&nbsp;&nbsp; \d = 0..9digit</tt><p>The modifier "i" after the last / means the match should be case insensitive...<p><tt>"PiIIg" =~ <b>/pIiig/</b>&nbsp;&nbsp;&nbsp;&nbsp; ==> FALSE</tt><br><tt>"PiIIg" =~ <b>/pIiig/i</b>&nbsp;&nbsp;&nbsp; ==> TRUE</tt><p>String interpolation works in regular expression patterns. The variablevalues are pasted into the expression once before it is evaluated. Characterslike * and + continue to have their special meanings in the pattern afterinterpolation, unless the pattern is bracketed with a \Q..\E. The followingexamples test if the pattern in $target occurs within brackets &lt; > in$string...<p><tt>$string =~ <b>/&lt;$target>/</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## Look for &lt;$target>, '.' '*' keep their special meanings in $target</tt><p><tt>$string =~ <b>/&lt;\Q$target\E>/</b>&nbsp;&nbsp;&nbsp; ## The \Q..\Eputs a backslash in front of every char,</tt><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## so '.' '*' etc. in $target will not have their special meanings</tt><p>Similar to the \Q..\E form, the quotemeta() function returns a stringwith every character \ escaped. There is an optional "m" (for "match")that comes before the first /. If the "m" is used, then any character canbe used for the delimiter instead of / -- so you could use " or # to delimitthe pattern. This is handy if what you are trying to match has a lot of/'s in it. If the delimiter is the single quote (') then interpolationis suppressed. The following expressions are all equivalent...<p><tt>"piiig" =~ <b>m/piiig/</b></tt><br><tt>"piiig" =~ <b>m"piiig"</b></tt><br><tt>"piiig" =~ <b>m#piiig#</b></tt><br>&nbsp;<h2>Control Codes</h2>Things get really interesting when you add in control codes to the regularexpression pattern...<ul><li><b>?</b>&nbsp;&nbsp; -- match 0 or 1 occurrences of the pattern to itsleft</li><li><b>*</b>&nbsp;&nbsp; -- 0 or more occurrences of the pattern to its left</li><li><b>+</b>&nbsp; -- 1 or more occurrences of the pattern to its left</li><li><b>|&nbsp;</b>&nbsp; -- (vertical bar)&nbsp; logical or -- matches thepattern either on its left or right</li><li>parenthesis <b>( )</b>&nbsp; -- group sequences of patterns</li><li><b>^</b>&nbsp;&nbsp; -- matches the start of the string</li><li><b>$</b>&nbsp;&nbsp; -- matches the end of the string</li></ul><h2>Leftmost &amp; Largest</h2>First, Perl tries to find the leftmost match for the pattern, and secondit tries to use up as much of the string as possible -- i.e. let + and* use up as many characters as possible.<h2>Regular Expression Examples</h2>The following series gradually demonstrate each of the above control codes.Study them carefully -- small details in regular expressions make a bigdifference. That's what makes them powerful, but it makes them tricky aswell.<p>Old joke: What do you call a pig with three eyes? Piiig!<pre>#### Search for the pattern 'iiig' in the string 'piiig'"piiig" =~ <b>m/iiig/</b> ==> TRUE#### The pattern may be anywhere inside the string"piiig" =~ <b>m/iii/</b> ==> TRUE#### All of the pattern must match"piiig" =~ <b>m/iiii/</b> ==> FALSE#### . = any char but \n"piiig" =~ <b>m/...ig/</b> ==> TRUE"piiig" =~ <b>m/p.i../</b> ==> TRUE#### The last . in the pattern is not matched"piiig" =~ <b>m/p.i.../</b> ==> FALSE#### \d = digit [0-9]"p123g" =~ <b>m/p\d\d\dg/</b> ==> TRUE"p123g" =~ <b>m/p\d\d\d\d/</b> ==> FALSE#### \w = letter or digit"p123g" =~ <b>m/\w\w\w\w\w/</b> ==> TRUE#### i+ = one or more i's"piiig" =~ <b>m/pi+g/</b> ==> TRUE#### matches iii"piiig" =~ <b>m/i+/</b> ==> TRUE"piiig" =~ <b>m/p+i+g+/</b> ==> TRUE"piiig" =~ <b>m/p+g+/</b> ==> FALSE#### i* = zero or more i's"piiig" =~ <b>m/pi*g/</b> ==> TRUE"piiig" =~ <b>m/p*i*g*/</b> ==> TRUE#### X* can match zero X's"piiig" =~ <b>m/pi*X*g/</b> ==> TRUE#### ^ = start, $ = end"piiig" =~ <b>m/^pi+g$/</b> ==> TRUE#### i is not at the start"piiig" =~ <b>m/^i+g$/</b> ==> FALSE#### i is not at the end"piiig" =~ <b>m/^pi+$/</b> ==> FALSE"piiig" =~ <b>m/^p.+g$/</b> ==> TRUE"piiig" =~ <b>m/^p.+$/</b> ==> TRUE"piiig" =~ <b>m/^.+$/</b> ==> TRUE#### g is not at the start"piiig" =~ <b>m/^g.+$/</b> ==> FALSE#### Needs at least one char after the g"piiig" =~ <b>m/g.+/</b> ==> FALSE#### Needs at least zero chars after the g"piiig" =~ <b>m/g.*/</b> ==> TRUE#### | = left or right expression"cat" =~ <b>m/^(cat|hat)$/</b> ==> TRUE"hat" =~ <b>m/^(cat|hat)$/</b> ==> TRUE"cathatcatcat" =~ <b>m/^(cat|hat)+$/</b> ==> TRUE"cathatcatcat" =~ <b>m/^(c|a|t|h)+$/</b> ==> TRUE"cathatcatcat" =~ <b>m/^(c|a|t)+$/</b> ==> FALSE#### Matches and stops at first 'cat'; does not get to 'catcat' on the right"cathatcatcat" =~ <b>m/(c|a|t)+/</b> ==> TRUE#### ? = optional"12121x2121x2" =~ <b>m/^(1x?2)+$/</b> ==> TRUE"aaaxbbbabaxbb" =~ <b>m/^(a+x?b+)+$/</b> ==> TRUE"aaaxxbbb" =~ <b>m/^(a+x?b+)+$/</b> ==> FALSE#### Three words separated by spaces"Easy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; does it" =~ <b>m/^\w+\s+\w+\s+\w+$/</b> ==> TRUE#### Just matches "gates@microsoft" -- \w does not match the ".""bill.gates@microsoft.com" =~ <b>m/\w+@\w+/</b> ==> TRUE#### Add the .'s to get the whole thing"bill.gates@microsoft.com" =~ <b>m/^(\w|\.)+@(\w|\.)+$/</b> ==> TRUE#### words separated by commas and possibly spaces"Klaatu,&nbsp;&nbsp; barada,nikto" =~ <b>m/^\w+(,\s*\w+)*$/</b> ==> TRUE</pre><h2>Character Classes</h2>Square brackets can be used to represent a set of characters. For example[aeiouAEIOU] is a one character pattern that matches a vowel. Most charactersare not special inside a square bracket and so can be used without a leadingbackslash (\). \w, \s, and \d work inside a character class, and the dash(-) can be used to express a range of characters, so [a-z] matches lowercase"a" through "z". So the \w code is equivalent to [a-zA-Z0-9]. If the firstcharacter in a character class is a caret (^) the set is inverted, andmatches all the characters <b>not</b> in the given set. So [^0-9] matchesall characters that are not digits.<p>The parts of an email address on either side of the "@" are made upof letters, numbers plus dots, underbars, and dashes. As a character classthat's just <tt>[\w._-]</tt>.<p><tt>"bill.gates_emporer@microsoft.com" =~ m/^[\w._-]+@[\w._-]+$/ ==>TRUE</tt><br>&nbsp;<h2>Match Variables</h2>If a =~ match expression is true, the special variables $1, $2, ... willbe the substrings that matched parts of the pattern in parenthesis -- $1matches the first left parenthesis, $2 the second left parenthesis, andso on. The following pattern picks out three words separated by whitespace...<p><tt>if ("this&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and that" =~ /(\w+)\s+(\w+)\s+(\w+)/){</tt><p><tt>&nbsp; ## if the above matches, $1=="this", $2=="and", $3=="that"</tt><p>This is a nice way to parse a string -- write a regular expression forthe pattern you expect putting parenthesis around the parts you want topull out. Only use $1, $2, etc. when the if =~ returns true. Other regular-expressionsystems use \1 and \2&nbsp; instead of $1 $2, and Perl supports that syntaxas well. There are three other special variables: $&amp; (dollar-ampersand)= the matched string, $` (dollar-back-quote) = the string before what wasmatched, and $' (dollar-quote) = the string following what was matched.<p>The following loop rips through a string and pulls out all the emailaddresses. It demonstrates using a character class, using $1 etc. to pullout parts of the match string, and using $' after the match.<p><tt>$str = 'blah blah nick@cs.stanford.edu, blah blah balh billg@microsoft.comblah blah';</tt><p><tt>while ($str =~ /(([\w._-]+)\@([\w._-]+))/) { ## look for an emailaddr</tt><br><tt>&nbsp; print "user:$2 host:$3&nbsp; all:$1\n";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## parts of the addr</tt><br><tt>&nbsp; $str = $';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ## set thestr to be the "rest" of the string</tt><br><tt>}</tt><p><tt>output:</tt><br><tt>user:nick host:cs.stanford.edu&nbsp; all:nick@cs.stanford.edu</tt><br><tt>user:billg host:microsoft.com&nbsp; all:billg@microsoft.com</tt><br>&nbsp;<h2>Substitution</h2>A slight variation of the match operator can be used to search and replace.Put an "s" in front of the pattern and follow the match pattern with areplacement pattern.<p><tt>## Change all "is" strings to "is not" -- a sure way to improveany document</tt><br><tt>$str =~ s/is/is not/ig;</tt><p>The replacement pattern can use $1, $2 to refer to parts of the matchedstring. The "g" modifier after the last / means do the replacement repeatedlyin the target string. The modifier "i" means the match should not be casesensitive. The following example finds instances of the letter "r" or "l"followed by a word character, and replaces that pattern with "w" followedby the same word character. Sounds like Tweety Bird...<p><tt>## Change "r" and "l" followed by a word char to "w" followed</tt><br><tt>## by the same word char</tt><br><tt>$x = "This dress exacerbates the genetic betrayal that is my Legacy.\n";</tt><br><tt>$x =~ s/(r|l)(\w)/w$2/ig;&nbsp;&nbsp;&nbsp; ## r or l followedby a word char</tt><br><tt>## $x is now "This dwess exacewbates the genetic betwayal thatis my wegacy."</tt><br>&nbsp;<h2>The ? Trick</h2>One problem with * and +, is that they are "greedy" -- they try to useup as many characters as they can. Suppose you are trying to pick out allof the characters between two curly braces { }. The simplest thing wouldbe to use the pattern...<p><tt>m/{(.*)}/&nbsp; -- pick up all the characters between {}'s</tt><p>The problem is that if you match against the string "{group 1} xx {group2}", the * will aggressively run right over the first } and match the second}. So $1 will be "group 1} xx {group 2" instead of "group 1". FortunatelyPerl has a nice solution to the too-aggressive-*/+ problem. If a ? immediatelyfollows the * or +, then it tries to find the <b>shortest</b> repetitionwhich works instead of the longest. You need the ? variant most often whenmatching with .* or \S* which can easily use up more than you had in mind.Use ".*?" to skip over stuff you don't care about, but have something youdo care about immediately to its right. Such as..<p><tt>m/{(.*?)}/ ## pick up all the characters between {}'s, but stop</tt><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##at the first }</tt><br>&nbsp;<p>The old way to skip everything up until a certain character, say },uses the [^}] construct like this...<p><tt>m/{([^}]*)}/ ## the inner [^}] matches any char except }</tt><p>I prefer the (.*?) form. In fact, I suspect it was added to the languageprecisely as an improvement over the [^}]* form.<h2>Substring</h2>The<tt> index(string, string-to-look-for, start-index) </tt>operator searchesthe first string starting at the given index for an occurrence of the secondstring. Returns the 0 based index of the first occurrence, or -1 if notfound. The following code uses index() to walk through a string and countthe number of times "binky" occurs.<p><tt>$count = 0;</tt><br><tt>$pos = 0;</tt><br><tt>while ( ($pos = index($string, "binky", $pos) != -1) {</tt><br><tt>&nbsp;$count++;</tt><br><tt>&nbsp;$pos++;</tt><br><tt>}</tt><br>&nbsp;<p>The function <tt>substr(string, index, length)</tt> pulls a substringout of the given string. Substr() starts at the given index and continuesfor the given length.<br>&nbsp;<h2>Split</h2>The split operator takes a regular expression, and a string, and returnsan array of all the substrings from the original string which were separatedby that regular expression. The following example pulls out words separatedby commas possibly with whitespace thrown in...<p><tt>split(/\s*,\s*/, "dress ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; betrayal&nbsp;&nbsp;&nbsp;,&nbsp; legacy") ## returns the array</tt><br><tt>&nbsp;&nbsp; ("dress", "betrayal", "legacy")</tt><br>&nbsp;<p>Split is often a useful way to pull an enumeration out of some textfor processing. If the number -1 is passed as a third argument to split,then it will interpret an instance of the separator pattern at the endof the string as marking a last, empty element (note the comma after thelast word)...<p><tt>split(/\s*,\s*/, "dress ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; betrayal&nbsp;&nbsp;&nbsp;,&nbsp; legacy,", -1) ## returns the array</tt><br><tt>&nbsp;&nbsp; ("dress", "betrayal", "legacy", "")</tt><br>&nbsp;<h2>Character Translate -- tr</h2>The tr// operator goes through a string and replaces characters with othercharacters.<p><tt>$string =~ tr/a/b/;&nbsp; -- change all a's to b's</tt><br><tt>$string =~ tr/A-Z/a-z/; -- change uppercase to lowercase&nbsp;&nbsp;(actually lc() is better for this)</tt><br>&nbsp;<br>&nbsp;<h1><a NAME="subroutines"></a>11. Subroutines</h1>Perl subroutines encapsulate blocks of code in the usual way. You do notneed to define subroutines before they are used, so Perl programs generallyhave their "main" code first, and their subroutines laid out toward thebottom of the file. A subroutine can return a scalar or an array.<p><tt>$x = Three();&nbsp; ## call to Three() returns 3</tt><br><tt>exit(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ## exit the programnormally</tt><p><tt>sub Three {</tt><br><tt>&nbsp;return (1 + 2);</tt><br><tt>}</tt><br>&nbsp;<h2>Local Variables and Parameters</h2>Historically, many Perl programs leave all of their variables global. It'sespecially convenient since the variables do not need to be declared. This"quick 'n dirty" style does not scale well when trying to write largerprograms. With Perl 5, the "my" construct allows one or more variablesto be declared. (Older versions of perl had a "local" construct which shouldbe avoided.)<p><tt>my $a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## declare $a</tt><br><tt>my $b = "hello"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## declare $b, and assign it "hello"</tt><br><tt>my @array = (1, 2, 3);&nbsp; ## declare @array and assign it (1,2, 3)</tt><br><tt>my ($x, $y);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## declare $x and $y</tt><br><tt>my ($a, $b) = (1, "hello");&nbsp;&nbsp;&nbsp; ## declare $a and$b, and assign $a=1, $b="hello"</tt><p>The "my" construct is most often used to declare local varaiables ina subroutine...<p><tt>sub Three {</tt><br><tt>&nbsp; my ($x, $y);&nbsp; # declare vars $x and $y</tt><br><tt>&nbsp; $x = 1;</tt><br><tt>&nbsp; $y = 2;</tt><br><tt>&nbsp; return ($x + $y);</tt><br><tt>}</tt><br>&nbsp;<p><tt># Variant of Three() which inits $x and $y with the array trick</tt><br><tt>sub Three2 {</tt><br><tt>&nbsp; my ($x, $y) = (1, 2);</tt><br><tt>&nbsp; return ($x + $y);</tt><br><tt>}</tt><br>&nbsp;<br>&nbsp;<h2>@_ Parameters</h2>Perl subroutines do not have formal named parameters like other languages.Instead, all the parameters are passed in a single array called "@_". Theelements in @_ actually point to the original caller-side parameters, sothe called function is responsible for making any copies. Usually the subroutinewill pull the values out of @_ and copy them to local variables. A Sum()function which takes two numbers and adds them looks like...<p><tt>sub Sum1 {</tt><br><tt>&nbsp;my ($x, $y) = @_; # the first lines of many functions looklike this</tt><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# to retrieve and name their params</tt><br><tt>&nbsp;return($x + $y);</tt><br><tt>}</tt><br>&nbsp;<p><tt># Variant where you pull the values out of @_ directly</tt><br><tt># This avoids copying the parameters</tt><br><tt>sub Sum2 {</tt><br><tt>&nbsp; return($_[0] + $_[1]);</tt><br><tt>}</tt><br>&nbsp;<p><tt># How Sum() would really be written in Perl -- it takes an array</tt><br><tt># of numbers of arbitrary length, and adds all of them...</tt><br><tt>sub Sum3 {</tt><br><tt>&nbsp; my ($sum, $elem); # declare local vars</tt><br><tt>&nbsp; $sum = 0;</tt><br><tt>&nbsp; foreach $elem (@_) {</tt><br><tt>&nbsp;&nbsp;&nbsp; $sum += $elem;</tt><br><tt>&nbsp; }</tt><br><tt>&nbsp; return($sum);</tt><br><tt>}</tt><br>&nbsp;<p><tt>## Variant of above using shift instead of foreach</tt><br><tt>sub sum4 {</tt><br><tt>&nbsp; my ($sum, $elem);</tt><br><tt>&nbsp; $sum = 0;</tt><br><tt>&nbsp; while(defined($elem = shift(@_))) {</tt><br><tt>&nbsp;&nbsp;&nbsp; $sum += $elem;</tt><br><tt>&nbsp; }</tt><br><tt>&nbsp; return($sum);</tt><br><tt>}</tt><br>&nbsp;<br>&nbsp;<h2>File Handle Arguments</h2>The file handles are all in a global namespace, so you cannot allocatethem locally like other variables. File handles can be passed from oneroutine to another like strings, but this amounts to just passing aroundreferences to a single global file handle...<p><tt>open(FILE, ">file.txt");</tt><br><tt>SayHello("FILE");</tt><br><tt>close(FILE);</tt><p><tt>## Here, the file handle FILE is passed as the string "FILE"</tt><br><tt>sub SayHello {</tt><br><tt>&nbsp; my($file_handle) = @_;</tt><p><tt>&nbsp; ## Prints to the file handle identified in $file_handle</tt><br><tt>&nbsp; print $file_handle "I'm a little teapot, short and stout.\n";</tt><br><tt>}</tt><p>Actually, the file handle doesn't even need to be quoted in the call,so the above call could be written as <tt>SayHello(FILE);</tt>. This isthe "bareword" feature of Perl where a group of characters that does nothave another syntactic interpretation is passed through as if it were astring. I prefer not to rely on barewords, so I write the call as <tt>SayHello("FILE");</tt>.<h2>Returning Multiple Values to the Caller</h2>How to communicate back to the caller? Returning a single value to thecaller works great when that's all you need. What about the case wherethere are multiple pieces of information to communicate back to the caller?The subroutine could communicate by modifying actual arguments in @_ ,but that gets ugly. A better approach is to pack multiple things into anarray and return that. The caller can catch the return array and use itas an array, or assign it to a my() expression that puts the values intonamed variables...<p><tt># Suppose this function returns a (num, string) array</tt><br><tt># where the num is a result code and the string is</tt><br><tt># the human readable form</tt><br><tt>sub DoSomething {</tt><br><tt>&nbsp; # does something</tt><br><tt>&nbsp; return(-13, "Core Breach Imminent!!"); # return an arraylen 2</tt><br><tt>}</tt><p><tt># so a call would look like...</tt><br><tt>my ($num, $string) = DoSomething();</tt><br><tt>if ($num&lt;0) {</tt><br><tt>&nbsp; print "Panic:$string\n";</tt><br><tt>}</tt><br>&nbsp;<p>The values returned must be scalars — if they themselves are arrays,they will be flattened into the return array which is probably not whatyou want.<h2>Flattened Arguments</h2>Perl arrays are always "1-deep" or "flat". The arguments into a functionall get "flattened" into the single @_ array, so it is not possible topass an array as one of several arguments since it gets flattened out withthe other arguments...<p><tt>Sum3(1, 2, (3, 4));</tt><br><tt>## returns 10 -- the arg array is flattened to (1, 2, 3, 4)</tt><br>&nbsp;<p>This flattening can hurt you if you try to assign to an element whichis an array...<p><tt>my(@nums, $three) = ((1, 2), 3);</tt><p>You might think that this assigns (1, 2) to @nums and 3 to $three. Butinstead the right hand side gets flattened to (1, 2, 3) which is then assignedto @nums, and $three does not get a value. Only use the my($x, $y) = (...);form when assigning a bunch of scalar values. If any of the values arearrays, then you should separate out all the assignments, each on its ownline...<p><tt>my (@array, $x);</tt><br><tt>@array = ...;</tt><br><tt>$x = ...;</tt><br>&nbsp;<p>You can get around the 1-deep by storing references to arrays in otherarrays -- see the References section.<h2>Global Vars and 'use strict'</h2>You need to be careful to keep local and global variables straight, sinceby default, the compiler does not warn about possibly erroneous code. Supposea subroutine has a $string local variable, except it is mistyped as $strningin one place. By default, this just declares a global variable named $strning.<p>Each of the following declarations causes Perl to enforce bug-reducingrules.<p><tt>use strict 'vars';&nbsp;&nbsp;&nbsp; ## enforce local/global vardeclarations</tt><br><tt>use strict;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## like above, but with some additional style checks</tt><p>With strict vars, variables inside functions must be declared with my().Variables which are intended to be global must be referred to with twocolons (::) in front of their name or must be declared with a global my().Violating these rules results in a compile-time error.<p><tt>## With strict vars...</tt><p><tt>## 1. Undeclared global vars must begin with "::" at all times</tt><br><tt>$::global = 13;</tt><p><tt>## 2. Or a global may be declared with a my(), in which case</tt><br><tt>## the :: is not necessary</tt><br><tt>my $global2 = 42;</tt><p><tt>sub foo {</tt><br><tt>&nbsp; my $sum;</tt><br><tt>&nbsp; $sum = $::global + $global2;</tt><br><tt>&nbsp; ## $sum and $global2 work without extra syntax</tt><br><tt>&nbsp; return($sum);</tt><br><tt>}</tt><p>Both the "-w" option and "use strict" are good ideas or any Perl programlarger than a page or two in size. Without them, you will inevitably wastetime debugging some trivial variable name mixup or syntax error.<br>&nbsp;<h1><a NAME="external"></a>11. Running External Programs</h1>Perl can be used to invoke other programs and mess with their input andoutput. The most straightforward way to do this is with the <tt>system</tt>function which takes a command line string (or an array of strings), andhas the operating system try to run it (this makes the most sense in aUnix environment). System returns 0&nbsp; when the program successfullycompletes, or on error the global variable <tt>$?</tt> should be set toan error description.<p><tt>system("mail nick &lt; tmp.txt") == 0 | die "system error $?";</tt><br>&nbsp;<p>The file-open function can also be used to run a program -- a verticalvar (|) at the end of the filename runs the filename as a process, andlets you read from its output...<p><tt>open(F, "ls -l |");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## run the ls -l process, and name its output F</tt><br><tt>while (defined($line = &lt;F>)) {&nbsp;&nbsp;&nbsp;&nbsp; ## readF, line by line</tt><br><tt>&nbsp;&nbsp;&nbsp; ...</tt><br>&nbsp;<p>The same trick works for writing to a process -- just put the verticalbar at the beginning. Writing on the file handle goes to the standard inputof the process. On Unix, the mail program can take the body of an emailmessage as standard input...<p><tt>$user = "nick\@cs";</tt><br><tt>$subject = "mail from perl";</tt><br><tt>open(MAIL, "| mail -s $subject $user");</tt><br><tt>print(MAIL, "Here's some email for you\n");</tt><br><tt>print(MAIL, "blah blah blah, ....");</tt><br><tt>close(MAIL);</tt><p>If a programmer ever uses this technique to send Spam email, then allthe other programmers will hunt that programmer down and explain the tragedyof&nbsp; the commons to them before the traditional beheading. Also, whenwriting a CGI, it's important that you control the sorts of strings thatare passed to system functions like open() and system(). Do not take textfrom the user and pass it directory to a call to system() or open() --the text must be checked to avoid errors and security problems.<br>&nbsp;<h1><a NAME="references"></a>12. References</h1>I'm happiest writing Perl code that does not use references because theyalways give me a mild headache. Here's the short version of how they work.The backslash operator (\) computes a reference to something. The referenceis a scalar that points to the original thing. The '$' dereferences toaccess the original thing.<p>Suppose there is a string...<p><tt>$str = "hello";&nbsp; ## original string</tt><p>And there is a reference that points to that string...<p><tt>$ref = \$str;&nbsp;&nbsp;&nbsp; ## compute $ref that points to $str</tt><p>The expression to access $str is $$ref. Essentially, the alphabeticpart of the variable, 'str', is replaced with the dereference expression'$ref'...<p><tt>print "$$ref\n"; ## prints "hello" -- identical to "$str\n";</tt><br>&nbsp;<p>Here's an example of the same principle with a reference to an array...<p><tt>@a = (1, 2, 3);&nbsp; ## original array</tt><p><tt>$aRef = \@a;&nbsp;&nbsp;&nbsp;&nbsp; ## reference to the array</tt><p><tt>print "a: @a\n";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ## prints"a: 1 2 3"</tt><br><tt>print "a: @$aRef\n";&nbsp;&nbsp;&nbsp; ## exactly the same</tt><br>&nbsp;<p>Curly braces { } can be added in code and in strings to help clarifythe stack of @, $, ...<p><tt>print "a: @{$aRef}\n";&nbsp; ## use { } for clarity</tt><br>&nbsp;<p>Here's how you put references to arrays in another array to make itlook two dimensional...<p><tt>@a = (1, 2, 3);</tt><br><tt>@b = (4, 5, 6);</tt><br><tt>@root = (\@a, \@b);</tt><p><tt>print "a: @a\n";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## a: (1 2 3)</tt><br><tt>print "a: @{$root[0]}\n";&nbsp;&nbsp; ## a: (1 2 3)</tt><br><tt>print "b: @{$root[1]}\n";&nbsp;&nbsp; ## b: (4 5 6)</tt><p><tt>scalar(@root)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##root len == 2</tt><br><tt>scalar(@{$root[0]})&nbsp;&nbsp; ## a len: == 3</tt><br>&nbsp;<p>For arrays of arrays, the [ ] operations can stack together so the syntaxis more C like...<p><tt>$root[1][0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;## this is 4</tt><br>&nbsp;<h1><a NAME="terse"></a>13. Terse Perl</h1>Perl supports a style of coding with very short phrases. For example, manybuilt in functions use the special scalar variable $_ if no other variableis specified. So file reading code...<p><tt>while ($line = &lt;FILE>) {</tt><br><tt>&nbsp;&nbsp;&nbsp; print $line;</tt><br><tt>}</tt><p>Can be written as...<p><tt>while (&lt;FILE>) {</tt><br><tt>&nbsp;&nbsp;&nbsp; print;</tt><br><tt>}</tt><p>It turns out that &lt;FILE> assigns its value into $_ if no variableis specified, and likewise print reads from $_ if nothing is specified.Perl is filled with little shortcuts like that, so many phrases can bewritten more tersely by omitting explicit variables. I don't especiallylike the "short" style, since I actually like having named variables inmy code, but obviously it depends on personal taste and the goal for thecode. If the code is going to be maintained or debugged by someone elsein the future, then named variables seem like a good idea.<br>&nbsp;<br>&nbsp;<h1><a NAME="revision"></a>Revision History</h1>This document started its life in 1998 and 1999 as a "quick perl" handoutfor Stanford's <a href="http://www.stanford.edu/class/cs193i/">InternetTechnologies</a> course. In the year 2000 I greatly expanded the documentand added it to the Stanford CS Education Library as document #108. In4/2001 and again in 5/2002 I did some moderate edits and additions. Thanksto Negar Shamma for the many suggestions.<br>&nbsp;<br>&nbsp;</body></html>